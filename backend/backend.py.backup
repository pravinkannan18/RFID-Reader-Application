import asyncio
import socket
import threading
import time
import sqlite3
import random
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, asdict

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

app = FastAPI(title="RFID Multi-Zone Monitor API")

# Enable CORS for frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Database Manager ---
class Database:
    def __init__(self, db_path="../rfid.db"):
        self.db_path = db_path
        self._init_tables()
    
    def _init_tables(self):
        """Initialize all database tables"""
        conn = sqlite3.connect(self.db_path)
        cur = conn.cursor()
        
        # Tag names table
        cur.execute("""
            CREATE TABLE IF NOT EXISTS rfid_names (
                id TEXT PRIMARY KEY,
                name TEXT
            )
        """)
        
        # Zones table
        cur.execute("""
            CREATE TABLE IF NOT EXISTS zones (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                reader_ip TEXT NOT NULL,
                reader_port INTEGER DEFAULT 2189,
                timeout REAL NOT NULL,
                mapped_zone_id TEXT,
                enabled BOOLEAN DEFAULT 1,
                simulation_mode BOOLEAN DEFAULT 0
            )
        """)
        
        # Tag history table
        cur.execute("""
            CREATE TABLE IF NOT EXISTS tag_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tag_id TEXT NOT NULL,
                zone_id TEXT NOT NULL,
                event_type TEXT,
                timestamp REAL NOT NULL
            )
        """)
        
        conn.commit()
        conn.close()
    
    def get_name(self, tag_id: str) -> str:
        try:
            conn = sqlite3.connect(self.db_path)
            cur = conn.cursor()
            cur.execute("SELECT name FROM rfid_names WHERE id = ?", (tag_id,))
            row = cur.fetchone()
            conn.close()
            return row[0] if row else "Unknown Asset"
        except Exception as e:
            print(f"DB Error: {e}")
            return tag_id
    
    def set_name(self, tag_id: str, name: str) -> bool:
        try:
            conn = sqlite3.connect(self.db_path)
            cur = conn.cursor()
            cur.execute("INSERT OR REPLACE INTO rfid_names (id, name) VALUES (?, ?)", (tag_id, name))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"DB Error setting name: {e}")
            return False
    
    # Zone Management
    def add_zone(self, zone_id: str, name: str, reader_ip: str, timeout: float, 
                 reader_port: int = 2189, mapped_zone_id: Optional[str] = None,
                 simulation_mode: bool = False) -> bool:
        try:
            conn = sqlite3.connect(self.db_path)
            cur = conn.cursor()
            cur.execute("""
                INSERT INTO zones (id, name, reader_ip, reader_port, timeout, mapped_zone_id, enabled, simulation_mode)
                VALUES (?, ?, ?, ?, ?, ?, 1, ?)
            """, (zone_id, name, reader_ip, reader_port, timeout, mapped_zone_id, simulation_mode))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"DB Error adding zone: {e}")
            return False
    
    def get_zones(self) -> List[Dict]:
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            cur = conn.cursor()
            cur.execute("SELECT * FROM zones WHERE enabled = 1")
            rows = cur.fetchall()
            conn.close()
            return [dict(row) for row in rows]
        except Exception as e:
            print(f"DB Error getting zones: {e}")
            return []
    
    def update_zone(self, zone_id: str, **kwargs) -> bool:
        try:
            conn = sqlite3.connect(self.db_path)
            cur = conn.cursor()
            
            # Build dynamic UPDATE query
            fields = []
            values = []
            for key, value in kwargs.items():
                if key in ['name', 'reader_ip', 'reader_port', 'timeout', 'mapped_zone_id', 'simulation_mode']:
                    fields.append(f"{key} = ?")
                    values.append(value)
            
            if not fields:
                return False
            
            values.append(zone_id)
            query = f"UPDATE zones SET {', '.join(fields)} WHERE id = ?"
            cur.execute(query, values)
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"DB Error updating zone: {e}")
            return False
    
    def delete_zone(self, zone_id: str) -> bool:
        try:
            conn = sqlite3.connect(self.db_path)
            cur = conn.cursor()
            cur.execute("UPDATE zones SET enabled = 0 WHERE id = ?", (zone_id,))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"DB Error deleting zone: {e}")
            return False
    
    def log_tag_event(self, tag_id: str, zone_id: str, event_type: str):
        try:
            conn = sqlite3.connect(self.db_path)
            cur = conn.cursor()
            cur.execute("""
                INSERT INTO tag_history (tag_id, zone_id, event_type, timestamp)
                VALUES (?, ?, ?, ?)
            """, (tag_id, zone_id, event_type, time.time()))
            conn.commit()
            conn.close()
        except Exception as e:
            print(f"DB Error logging event: {e}")

db = Database()

# --- Zone Monitor ---
class ZoneMonitor:
    """Monitors a single zone's RFID reader"""
    
    def __init__(self, zone_id: str, name: str, reader_ip: str, reader_port: int, 
                 timeout: float, simulation_mode: bool = False):
        self.zone_id = zone_id
        self.name = name
        self.reader_ip = reader_ip
        self.reader_port = reader_port
        self.timeout = timeout
        self.simulation_mode = simulation_mode
        
        self.running = False
        self.connection_state = "disconnected"
        self.seen_tags: Dict[str, float] = {}
        self.latest_tags: List[str] = []
        self.lock = threading.Lock()
        self.thread: Optional[threading.Thread] = None
        self.logs: List[Dict] = []
        
        # Simulation state
        self.simulated_pool = [f"E2001000{i:04X}" for i in range(1, 10)]
    
    def log(self, msg, type="info"):
        t = datetime.now().strftime("%H:%M:%S")
        with self.lock:
            self.logs.append({"time": t, "msg": f"[{self.name}] {msg}", "type": type})
            if len(self.logs) > 30:
                self.logs.pop(0)
        print(f"[{type.upper()}] [{self.name}] {msg}")
    
    def start(self):
        if self.running:
            return
        self.running = True
        self.log(f"Starting monitor on {self.reader_ip}...", "info")
        self.thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.thread.start()
    
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join(timeout=1.0)
        self.connection_state = "disconnected"
        self.log("Monitor stopped", "warn")
        with self.lock:
            self.seen_tags.clear()
    
    def _monitor_loop(self):
        while self.running:
            try:
                if not self.simulation_mode:
                    self.connection_state = "connecting"
                    self.log(f"Connecting to {self.reader_ip}:{self.reader_port}...", "info")
                    
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(2.0)
                        try:
                            s.connect((self.reader_ip, int(self.reader_port)))
                            self.connection_state = "connected"
                            self.log(f"Connected successfully", "success")
                            
                            while self.running:
                                s.sendall(b"READ\r\n")
                                resp = ""
                                start_time = time.time()
                                
                                while time.time() - start_time < 2.0:
                                    try:
                                        chunk = s.recv(4096).decode('utf-8', errors='ignore')
                                        resp += chunk
                                        if "OK>" in chunk or "ERR>" in chunk:
                                            break
                                    except socket.timeout:
                                        break
                                    except Exception:
                                        break
                                
                                current_read = []
                                lines = resp.splitlines()
                                now = time.time()
                                
                                with self.lock:
                                    for line in lines:
                                        tag = line.strip()
                                        if tag and not tag.startswith(('OK>', 'ERR>')):
                                            current_read.append(tag)
                                            if tag not in self.seen_tags:
                                                db.log_tag_event(tag, self.zone_id, "entered")
                                            self.seen_tags[tag] = now
                                    self.latest_tags = current_read
                                
                                time.sleep(0.4)
                        
                        except Exception as e:
                            self.connection_state = "failed"
                            self.log(f"Connection failed: {e}", "error")
                            time.sleep(2.0)
                else:
                    # SIMULATION MODE
                    self.connection_state = "connected"
                    if not self.latest_tags:
                        self.log("Simulation started", "success")
                    
                    now = time.time()
                    visible = [t for t in self.simulated_pool if random.random() > 0.15]
                    
                    with self.lock:
                        for tag in visible:
                            if tag not in self.seen_tags:
                                db.log_tag_event(tag, self.zone_id, "entered")
                            self.seen_tags[tag] = now
                        self.latest_tags = visible
                    
                    time.sleep(0.5)
            
            except Exception as e:
                self.log(f"Monitor Loop Error: {e}", "error")
                self.connection_state = "failed"
                time.sleep(1.0)
    
    def get_status(self) -> Dict:
        now = time.time()
        with self.lock:
            active_tags = []
            missing_tags = []
            
            for tag, last_seen in self.seen_tags.items():
                age = now - last_seen
                name = db.get_name(tag)
                
                info = {
                    "id": tag,
                    "name": name,
                    "last_seen": last_seen,
                    "age_seconds": round(age, 1)
                }
                
                if age > self.timeout:
                    missing_tags.append(info)
                else:
                    active_tags.append(info)
            
            return {
                "zone_id": self.zone_id,
                "zone_name": self.name,
                "connection_state": self.connection_state,
                "monitoring": self.running,
                "ip": self.reader_ip,
                "active_count": len(active_tags),
                "missing_count": len(missing_tags),
                "active_tags": sorted(active_tags, key=lambda x: x['age_seconds']),
                "missing_tags": sorted(missing_tags, key=lambda x: x['age_seconds'], reverse=True),
                "logs": list(self.logs)
            }

# --- Multi-Zone Manager ---
class MultiZoneManager:
    """Manages multiple zone monitors"""
    
    def __init__(self):
        self.zones: Dict[str, ZoneMonitor] = {}
        self.lock = threading.Lock()
        self._load_zones()
    
    def _load_zones(self):
        """Load zones from database on startup"""
        zones_data = db.get_zones()
        for zone_data in zones_data:
            self.add_zone_monitor(
                zone_id=zone_data['id'],
                name=zone_data['name'],
                reader_ip=zone_data['reader_ip'],
                reader_port=zone_data['reader_port'],
                timeout=zone_data['timeout'],
                simulation_mode=bool(zone_data['simulation_mode'])
            )
    
    def add_zone_monitor(self, zone_id: str, name: str, reader_ip: str, reader_port: int,
                         timeout: float, simulation_mode: bool = False):
        with self.lock:
            if zone_id not in self.zones:
                monitor = ZoneMonitor(zone_id, name, reader_ip, reader_port, timeout, simulation_mode)
                self.zones[zone_id] = monitor
    
    def remove_zone_monitor(self, zone_id: str):
        with self.lock:
            if zone_id in self.zones:
                self.zones[zone_id].stop()
                del self.zones[zone_id]
    
    def start_zone(self, zone_id: str):
        with self.lock:
            if zone_id in self.zones:
                self.zones[zone_id].start()
    
    def stop_zone(self, zone_id: str):
        with self.lock:
            if zone_id in self.zones:
                self.zones[zone_id].stop()
    
    def start_all(self):
        with self.lock:
            for monitor in self.zones.values():
                monitor.start()
    
    def stop_all(self):
        with self.lock:
            for monitor in self.zones.values():
                monitor.stop()
    
    def get_all_status(self) -> Dict:
        with self.lock:
            zones_status = []
            all_logs = []
            
            for monitor in self.zones.values():
                status = monitor.get_status()
                zones_status.append(status)
                all_logs.extend(status.get('logs', []))
            
            # Sort logs by time (most recent last)
            all_logs = sorted(all_logs, key=lambda x: x['time'])[-50:]
            
            return {
                "zones": zones_status,
                "total_zones": len(self.zones),
                "active_zones": sum(1 for m in self.zones.values() if m.running),
                "logs": all_logs
            }
    
    def detect_transfers(self) -> List[Dict]:
        """Detect tags that transferred between zones"""
        transfers = []
        zones_data = db.get_zones()
        zone_map = {z['id']: z for z in zones_data}
        
        with self.lock:
            for zone_id, monitor in self.zones.items():
                mapped_zone_id = zone_map.get(zone_id, {}).get('mapped_zone_id')
                if not mapped_zone_id or mapped_zone_id not in self.zones:
                    continue
                
                mapped_monitor = self.zones[mapped_zone_id]
                now = time.time()
                
                # Check for tags missing from this zone
                for tag_id, last_seen in monitor.seen_tags.items():
                    age = now - last_seen
                    if age > monitor.timeout:
                        # Check if tag appeared in mapped zone within timeout window
                        if tag_id in mapped_monitor.seen_tags:
                            mapped_last_seen = mapped_monitor.seen_tags[tag_id]
                            if mapped_last_seen > last_seen:  # Tag appeared in mapped zone after leaving this zone
                                transfers.append({
                                    "tag_id": tag_id,
                                    "tag_name": db.get_name(tag_id),
                                    "from_zone": monitor.name,
                                    "to_zone": mapped_monitor.name,
                                    "timestamp": mapped_last_seen
                                })
        
        return transfers

manager = MultiZoneManager()

# --- API Models ---
class ZoneCreate(BaseModel):
    name: str
    reader_ip: str
    reader_port: int = 2189
    timeout: float = 8.0
    mapped_zone_id: Optional[str] = None
    simulation_mode: bool = False

class ZoneUpdate(BaseModel):
    name: Optional[str] = None
    reader_ip: Optional[str] = None
    reader_port: Optional[int] = None
    timeout: Optional[float] = None
    mapped_zone_id: Optional[str] = None
    simulation_mode: Optional[bool] = None

class SetNameReq(BaseModel):
    tag_id: str
    name: str

# --- API Endpoints ---

@app.get("/health")
def health():
    return {"status": "ok", "mode": "multi-zone"}

# Zone Management
@app.post("/zones")
def create_zone(zone: ZoneCreate):
    zone_id = str(uuid.uuid4())
    success = db.add_zone(
        zone_id=zone_id,
        name=zone.name,
        reader_ip=zone.reader_ip,
        reader_port=zone.reader_port,
        timeout=zone.timeout,
        mapped_zone_id=zone.mapped_zone_id,
        simulation_mode=zone.simulation_mode
    )
    
    if success:
        manager.add_zone_monitor(
            zone_id=zone_id,
            name=zone.name,
            reader_ip=zone.reader_ip,
            reader_port=zone.reader_port,
            timeout=zone.timeout,
            simulation_mode=zone.simulation_mode
        )
        return {"status": "success", "zone_id": zone_id}
    else:
        raise HTTPException(status_code=500, detail="Failed to create zone")

@app.get("/zones")
def list_zones():
    return {"zones": db.get_zones()}

@app.put("/zones/{zone_id}")
def update_zone(zone_id: str, zone: ZoneUpdate):
    updates = {k: v for k, v in zone.dict().items() if v is not None}
    success = db.update_zone(zone_id, **updates)
    
    if success:
        # Restart monitor with new config
        manager.remove_zone_monitor(zone_id)
        zone_data = next((z for z in db.get_zones() if z['id'] == zone_id), None)
        if zone_data:
            manager.add_zone_monitor(
                zone_id=zone_data['id'],
                name=zone_data['name'],
                reader_ip=zone_data['reader_ip'],
                reader_port=zone_data['reader_port'],
                timeout=zone_data['timeout'],
                simulation_mode=bool(zone_data['simulation_mode'])
            )
        return {"status": "success"}
    else:
        raise HTTPException(status_code=500, detail="Failed to update zone")

@app.delete("/zones/{zone_id}")
def delete_zone(zone_id: str):
    success = db.delete_zone(zone_id)
    if success:
        manager.remove_zone_monitor(zone_id)
        return {"status": "success"}
    else:
        raise HTTPException(status_code=500, detail="Failed to delete zone")

# Zone Control
@app.post("/zones/{zone_id}/start")
def start_zone(zone_id: str):
    manager.start_zone(zone_id)
    return {"status": "started", "zone_id": zone_id}

@app.post("/zones/{zone_id}/stop")
def stop_zone(zone_id: str):
    manager.stop_zone(zone_id)
    return {"status": "stopped", "zone_id": zone_id}

@app.post("/zones/start-all")
def start_all_zones():
    manager.start_all()
    return {"status": "all_started"}

@app.post("/zones/stop-all")
def stop_all_zones():
    manager.stop_all()
    return {"status": "all_stopped"}

# Tag Management
@app.post("/tag/name")
def set_tag_name(req: SetNameReq):
    success = db.set_name(req.tag_id, req.name)
    if success:
        return {"status": "success", "tag_id": req.tag_id, "name": req.name}
    else:
        raise HTTPException(status_code=500, detail="Failed to update tag name")

# Status & Monitoring
@app.get("/status")
def get_status():
    status = manager.get_all_status()
    status['transfers'] = manager.detect_transfers()
    return status

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            status = manager.get_all_status()
            status['transfers'] = manager.detect_transfers()
            await websocket.send_json(status)
            await asyncio.sleep(0.5)
    except WebSocketDisconnect:
        print("Client disconnected")
    except Exception as e:
        print(f"WS Error: {e}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
